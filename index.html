<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasyscapes Map Generator</title>
    
    <!-- Load React -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Load Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
                Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- Load your modified React component -->
    <script type="text/babel">
        // Create React component
        const FantasyMapGenerator = () => {
          const canvasRef = React.useRef(null);
          const [seed, setSeed] = React.useState(Math.floor(Math.random() * 1000000));
          const [mapStyle, setMapStyle] = React.useState('parchment'); // Options: 'parchment', 'color'
          const [mapSize, setMapSize] = React.useState({ width: 800, height: 600 });
          const [featureSettings, setFeatureSettings] = React.useState({
            mountainDensity: 0.5,
            forestDensity: 0.6,
            riverCount: 5,
            cityCount: 7,
            includeRoads: true,
            includeLabels: true,
            oceanDepth: 0.65 // Threshold for water level
          });
          const [isGenerating, setIsGenerating] = React.useState(false);

          // Import icons from lucide global variable
          const { Download, RefreshCcw } = lucide;

          // Include the rest of your main.js code here
          // --- Perlin Noise Function ---
          const generateNoise = (width, height, inputSeed, scale = 20, octaves = 6, persistence = 0.5, lacunarity = 2) => {
            const noise = new Array(width * height).fill(0);
            let currentSeed = inputSeed;

            // Simple Pseudo-Random Number Generator (PRNG) based on the seed
            const random = () => {
              currentSeed = (currentSeed * 9301 + 49297) % 233280;
              const rnd = currentSeed / 233280.0;
              return rnd;
            };

            // Generate gradient vectors using the seeded PRNG
            const gradients = [];
            for (let i = 0; i < 256; i++) {
              const angle = random() * Math.PI * 2;
              gradients.push([Math.cos(angle), Math.sin(angle)]);
            }

            // Permutation table using the seeded PRNG
            const p = [];
            for (let i = 0; i < 256; i++) {
              p[i] = i;
            }
            for (let i = 255; i > 0; i--) {
              const j = Math.floor(random() * (i + 1));
              [p[i], p[j]] = [p[j], p[i]]; // Shuffle
            }
            const perm = [...p, ...p]; // Double the permutation table to avoid index wrapping issues

            // Fade function (improves visual quality)
            const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);

            // Linear interpolation
            const lerp = (t, a, b) => a + t * (b - a);

            // Calculate gradient dot product
            const grad = (hash, x, y) => {
              const g = gradients[hash % 256]; // Use seeded gradients
              return g[0] * x + g[1] * y;
            };

            // Generate Perlin noise
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                let amplitude = 1;
                let frequency = 1;
                let noiseValue = 0;
                let maxAmplitude = 0; // For normalization

                for (let o = 0; o < octaves; o++) {
                  const sampleX = x / scale * frequency;
                  const sampleY = y / scale * frequency;

                  const X = Math.floor(sampleX) & 255;
                  const Y = Math.floor(sampleY) & 255;

                  const xf = sampleX - Math.floor(sampleX);
                  const yf = sampleY - Math.floor(sampleY);

                  const u = fade(xf);
                  const v = fade(yf);

                  // Hash coordinates of the 4 corners
                  const aa = perm[X] + Y;
                  const ab = perm[X] + Y + 1;
                  const ba = perm[X + 1] + Y;
                  const bb = perm[X + 1] + Y + 1;

                  // Calculate dot products and interpolate
                  const noiseAtPoint = lerp(v, lerp(u, grad(perm[aa], xf, yf), grad(perm[ba], xf - 1, yf)),
                                            lerp(u, grad(perm[ab], xf, yf - 1), grad(perm[bb], xf - 1, yf - 1)));

                  noiseValue += noiseAtPoint * amplitude;
                  maxAmplitude += amplitude;
                  amplitude *= persistence;
                  frequency *= lacunarity;
                }

                // Store the normalized noise value
                noise[y * width + x] = (noiseValue / maxAmplitude + 1) / 2; // Normalize to [0, 1] range
              }
            }
            return noise;
          };

          // --- Include the rest of your functions here ---
          // For brevity, I'm not including all of them in this edit, but you should copy them from main.js
          
          // --- Terrain Generation ---
          const generateTerrain = (ctx, width, height, currentSeed) => {
            setIsGenerating(true); // Indicate generation started
            console.time('generateTerrain');

            // Generate base terrain and detail noise using the current seed
            const terrainNoise = generateNoise(width, height, currentSeed, 100, 8, 0.5, 2);
            const detailNoise = generateNoise(width, height, currentSeed + 1, 50, 6, 0.6, 2.2); // Use a different seed offset for detail

            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const { oceanDepth } = featureSettings;

            // Color definitions based on style
            let deepOcean, ocean, shallowWater, sand, grass, forestTerrain, mountain, snowPeak;

            if (mapStyle === 'color') {
              deepOcean = [10, 30, 70, 255];
              ocean = [65, 105, 170, 255];
              shallowWater = [100, 142, 190, 255];
              sand = [238, 214, 175, 255];
              grass = [124, 184, 104, 255]; // Brighter green
              forestTerrain = [80, 140, 80, 255]; // Darker green for forest base
              mountain = [150, 142, 134, 255]; // Slightly browner mountains
              snowPeak = [245, 245, 245, 255];
            } else { // Parchment style (subdued colors)
              deepOcean = [180, 170, 140, 255]; // Darker parchment water
              ocean = [200, 190, 160, 255];
              shallowWater = [210, 200, 170, 255];
              sand = [225, 210, 180, 255]; // Parchment sand
              grass = [205, 195, 170, 255]; // Light greenish-brown
              forestTerrain = [190, 185, 160, 255]; // Slightly darker/greener
              mountain = [170, 165, 155, 255]; // Greyish-brown
              snowPeak = [230, 230, 225, 255]; // Off-white
            }

            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const i = (y * width + x);
                const idx = i * 4;
                const noiseValue = terrainNoise[i];
                const detailValue = detailNoise[i];

                let color;
                if (noiseValue < oceanDepth - 0.15) { color = deepOcean; }
                else if (noiseValue < oceanDepth - 0.05) { color = ocean; }
                else if (noiseValue < oceanDepth) { color = shallowWater; }
                else if (noiseValue < oceanDepth + 0.03) { color = sand; }
                else if (noiseValue < oceanDepth + 0.3) { color = grass; }
                else if (noiseValue < oceanDepth + 0.45) { color = forestTerrain; } // Use forest base color
                else if (noiseValue < oceanDepth + 0.6) { color = mountain; }
                else { color = snowPeak; }

                // Apply detail noise for slightly more natural color variation
                const detailInfluence = mapStyle === 'color' ? 0.1 : 0.05; // Less influence on parchment
                data[idx] = Math.min(255, Math.max(0, color[0] + (detailValue - 0.5) * detailInfluence * 50));
                data[idx + 1] = Math.min(255, Math.max(0, color[1] + (detailValue - 0.5) * detailInfluence * 50));
                data[idx + 2] = Math.min(255, Math.max(0, color[2] + (detailValue - 0.5) * detailInfluence * 50));
                data[idx + 3] = color[3];
              }
            }

            ctx.putImageData(imageData, 0, 0);
            console.timeEnd('generateTerrain');
            setIsGenerating(false); // Generation finished
            return terrainNoise; // Return noise for other features
          };

          // Include all other functions: generateMountains, generateForests, etc.
          // ...

          // --- Main Map Generation Function ---
          const generateMap = () => {
            console.log(`Generating map with seed: ${seed}, style: ${mapStyle}`);
            console.time('generateMapTotal');
            const canvas = canvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const { width, height } = mapSize;

            // Ensure canvas dimensions are set
            canvas.width = width;
            canvas.height = height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);
             ctx.fillStyle = mapStyle === 'parchment' ? '#E3D9BB' : '#4169E1'; // Parchment base or Royal Blue ocean base
             ctx.fillRect(0, 0, width, height);


            // Use a local variable for the seed for this generation run
            const currentSeed = seed;

            // Generate base terrain (returns noise data)
            const terrainNoise = generateTerrain(ctx, width, height, currentSeed);

            // Add minimal features for initial test
            ctx.fillStyle = '#333';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Map generated with seed: ${seed}`, width/2, height/2);

            console.timeEnd('generateMapTotal');
          };

          // --- Event Handlers ---
          const handleDownload = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const link = document.createElement('a');
            link.download = `fantasy-map-${mapStyle}-${seed}.png`;
            link.href = canvas.toDataURL('image/png'); // Get data URL
            document.body.appendChild(link); // Required for Firefox
            link.click();
            document.body.removeChild(link); // Clean up
             console.log("Map download initiated.");
          };

          const handleRegenerateMap = () => {
             console.log("Regenerating map with new seed...");
            setSeed(Math.floor(Math.random() * 1000000)); // Generate new seed triggers useEffect
          };

          const handleUpdateSetting = (setting, value) => {
             // Ensure numeric values from sliders/inputs are treated as numbers
            const numericSettings = ['mountainDensity', 'forestDensity', 'riverCount', 'cityCount', 'oceanDepth'];
            const processedValue = numericSettings.includes(setting) ? Number(value) : value;

             console.log(`Updating setting: ${setting} to ${processedValue}`);
            setFeatureSettings(prev => ({
              ...prev,
              [setting]: processedValue // Use processed value
            }));
          };

          const handleChangeMapStyle = (style) => {
              console.log(`Changing map style to: ${style}`);
              setMapStyle(style);
          };

          // --- useEffect Hook ---
          React.useEffect(() => {
              generateMap();
          }, [seed, mapStyle, featureSettings, mapSize]);

          // --- JSX ---
          return (
            <div className="flex flex-col items-center p-4 bg-gray-100 min-h-screen">
                <h1 className="text-3xl font-bold mb-4 text-gray-800">Fantasyscapes Map Generator</h1>

                {/* Controls Section */}
                <div className="w-full max-w-4xl bg-white p-4 rounded shadow mb-4 flex flex-wrap gap-4 justify-between items-start">

                   {/* Left Side Controls: Generation & Style */}
                   <div className="flex flex-col gap-3">
                        {/* Seed & Regenerate */}
                        <div className="flex items-center gap-2">
                            <button
                                onClick={handleRegenerateMap}
                                className="p-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition duration-150 flex items-center gap-1 disabled:opacity-50"
                                title="Generate New Map (Random Seed)"
                                disabled={isGenerating}
                            >
                                <RefreshCcw size={18} />
                                Regenerate
                            </button>
                            <span className="text-sm text-gray-600">Seed: {seed}</span>
                        </div>

                        {/* Map Style */}
                        <div className="flex flex-col">
                             <label className="block text-sm font-medium text-gray-700 mb-1">Map Style:</label>
                             <div className="flex gap-3">
                                <button
                                    onClick={() => handleChangeMapStyle('parchment')}
                                    className={`px-3 py-1 text-sm rounded ${mapStyle === 'parchment' ? 'bg-amber-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                    disabled={isGenerating}
                                >
                                    Parchment
                                </button>
                                 <button
                                    onClick={() => handleChangeMapStyle('color')}
                                    className={`px-3 py-1 text-sm rounded ${mapStyle === 'color' ? 'bg-teal-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                    disabled={isGenerating}
                                >
                                    Color
                                </button>
                             </div>
                        </div>

                        {/* Download Button */}
                         <button
                            onClick={handleDownload}
                            className="p-2 bg-green-500 text-white rounded hover:bg-green-600 transition duration-150 flex items-center gap-1 disabled:opacity-50"
                             disabled={isGenerating}
                             title="Download Map as PNG"
                         >
                            <Download size={18} />
                            Download Map
                        </button>
                   </div>

                    {/* Right Side Controls: Feature Settings */}
                    <div className="flex flex-col gap-3 flex-grow" style={{minWidth: '250px'}}>
                        <h2 className="text-lg font-semibold text-gray-700 mb-1">Features</h2>

                        {/* Sliders */}
                         <div className="grid grid-cols-2 gap-x-4 gap-y-2">
                            <label htmlFor="oceanDepth" className="text-sm text-gray-600 self-center">Ocean Level:</label>
                            <input type="range" id="oceanDepth" name="oceanDepth" min="0.3" max="0.8" step="0.01"
                                   value={featureSettings.oceanDepth}
                                   onChange={(e) => handleUpdateSetting(e.target.name, e.target.value)}
                                   className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 self-center"
                                   disabled={isGenerating} />

                            <label htmlFor="mountainDensity" className="text-sm text-gray-600 self-center">Mountains:</label>
                            <input type="range" id="mountainDensity" name="mountainDensity" min="0" max="1" step="0.05"
                                   value={featureSettings.mountainDensity}
                                   onChange={(e) => handleUpdateSetting(e.target.name, e.target.value)}
                                   className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 self-center"
                                    disabled={isGenerating} />

                            <label htmlFor="forestDensity" className="text-sm text-gray-600 self-center">Forests:</label>
                            <input type="range" id="forestDensity" name="forestDensity" min="0" max="1" step="0.05"
                                   value={featureSettings.forestDensity}
                                   onChange={(e) => handleUpdateSetting(e.target.name, e.target.value)}
                                   className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 self-center"
                                    disabled={isGenerating} />

                             <label htmlFor="riverCount" className="text-sm text-gray-600 self-center">Rivers:</label>
                            <input type="range" id="riverCount" name="riverCount" min="0" max="15" step="1"
                                   value={featureSettings.riverCount}
                                   onChange={(e) => handleUpdateSetting(e.target.name, e.target.value)}
                                   className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 self-center"
                                    disabled={isGenerating} />

                              <label htmlFor="cityCount" className="text-sm text-gray-600 self-center">Cities:</label>
                            <input type="range" id="cityCount" name="cityCount" min="0" max="20" step="1"
                                   value={featureSettings.cityCount}
                                   onChange={(e) => handleUpdateSetting(e.target.name, e.target.value)}
                                   className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 self-center"
                                    disabled={isGenerating} />
                         </div>

                        {/* Checkboxes */}
                         <div className="flex gap-4 mt-2">
                            <label className="flex items-center gap-1 text-sm text-gray-600">
                                <input type="checkbox" name="includeLabels"
                                       checked={featureSettings.includeLabels}
                                       onChange={(e) => handleUpdateSetting(e.target.name, e.target.checked)}
                                       className="rounded text-blue-500 focus:ring-blue-400"
                                        disabled={isGenerating} />
                                Labels
                            </label>
                            <label className="flex items-center gap-1 text-sm text-gray-600">
                                <input type="checkbox" name="includeRoads"
                                       checked={featureSettings.includeRoads}
                                       onChange={(e) => handleUpdateSetting(e.target.name, e.target.checked)}
                                       className="rounded text-blue-500 focus:ring-blue-400"
                                        disabled={isGenerating} />
                                Roads
                            </label>
                         </div>
                    </div>
                </div>

                {/* Canvas Section */}
                <div className="w-full max-w-4xl bg-white p-1 rounded shadow relative">
                    {isGenerating && (
                         <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
                            <span className="text-white text-xl">Generating...</span>
                         </div>
                    )}
                    <canvas
                        ref={canvasRef}
                        width={mapSize.width}
                        height={mapSize.height}
                        className="block border border-gray-300 rounded" // Added border for visibility
                        style={{ maxWidth: '100%', height: 'auto' }} // Responsive canvas sizing
                    >
                        Your browser does not support the canvas element.
                    </canvas>
                </div>

                 {/* Footer/Info */}
                 <p className="text-xs text-gray-500 mt-4">
                     Map generation uses seeded Perlin noise. Different seeds produce different maps.
                 </p>
            </div>
          );
        };

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FantasyMapGenerator />);
    </script>
</body>
</html> 